#!/bin/bash

# COmanage Registry Dockerfile entrypoint
#
# Portions licensed to the University Corporation for Advanced Internet
# Development, Inc. ("UCAID") under one or more contributor license agreements.
# See the NOTICE file distributed with this work for additional information
# regarding copyright ownership.
#
# UCAID licenses this file to you under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with the
# License. You may obtain a copy of the License at:
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

if [ -n "$COMANAGE_DEBUG" ]
then
    OUTPUT=/dev/stdout
else
    OUTPUT=/dev/null
fi

# Configuration details that may be injected through environment
# variables or the contents of files.

injectable_config_vars=( 
    COMANAGE_REGISTRY_DATASOURCE
    COMANAGE_REGISTRY_DATABASE
    COMANAGE_REGISTRY_DATABASE_HOST
    COMANAGE_REGISTRY_DATABASE_USER
    COMANAGE_REGISTRY_DATABASE_USER_PASSWORD
    COMANAGE_REGISTRY_EMAIL_FROM
    COMANAGE_REGISTRY_EMAIL_TRANSPORT
    COMANAGE_REGISTRY_EMAIL_HOST
    COMANAGE_REGISTRY_EMAIL_PORT
    COMANAGE_REGISTRY_EMAIL_ACCOUNT
    COMANAGE_REGISTRY_EMAIL_ACCOUNT_PASSWORD
    COMANAGE_REGISTRY_SECURITY_SALT
    COMANAGE_REGISTRY_SECURITY_SEED
    HTTPS_CERT_FILE
    HTTPS_PRIVKEY_FILE
    HTTPS_CHAIN_FILE
)

# If the file associated with a configuration variable is present then 
# read the value from it into the appropriate variable. So for example
# if the variable COMANAGE_REGISTRY_DATASOURCE_FILE exists and its
# value points to a file on the file system then read the contents
# of that file into the variable COMANAGE_REGISTRY_DATASOURCE.

for config_var in "${injectable_config_vars[@]}"
do
    eval file_name=\$"${config_var}_FILE";

    if [ -e "$file_name" ]; then
        declare "${config_var}"=`cat $file_name`
    fi
done

# Make sure the directory structure we need is available
# in the data volume for $COMANAGE_REGISTRY_DIR/local
mkdir -p "$COMANAGE_REGISTRY_DIR/local/Config"
mkdir -p "$COMANAGE_REGISTRY_DIR/local/Plugin"
mkdir -p "$COMANAGE_REGISTRY_DIR/local/View/Pages/public"
mkdir -p "$COMANAGE_REGISTRY_DIR/local/webroot/img"

# If the COmanage Registry database configuration file does not exist
# then try to create it from injected information with reasonable defaults
# that aid simple evaluation deployments.
if [ ! -e "$COMANAGE_REGISTRY_DIR/local/Config/database.php" ]; then
    cat >> "$COMANAGE_REGISTRY_DIR/local/Config/database.php" <<EOF
<?php

class DATABASE_CONFIG {

  public \$default = array(
    'datasource' => '${COMANAGE_REGISTRY_DATASOURCE:-Database/Postgres}',
    'persistent' => false,
    'host' => '${COMANAGE_REGISTRY_DATABASE_HOST:-comanage-registry-database}',
    'login' => '${COMANAGE_REGISTRY_DATABASE_USER:-registry_user}',
    'password' => '${COMANAGE_REGISTRY_DATABASE_USER_PASSWORD:-password}',
    'database' => '${COMANAGE_REGISTRY_DATABASE:-registry}',
    'prefix' => 'cm_',
  );

}
EOF
fi

# If the COmanage Registry email configuration file does not exist
# then try to create it from injected information with reasonable defaults
# that aid simple evaluation deployments.
email_config="$COMANAGE_REGISTRY_DIR/local/Config/email.php"

if [ ! -e "$email_config" ]; then
    cat >> "$email_config" <<EOF
<?php

class EmailConfig {

  public \$default = array(
    'from' => ${COMANAGE_REGISTRY_EMAIL_FROM:-array('account@gmail.com' => 'Registry')},
    'transport' => '${COMANAGE_REGISTRY_EMAIL_TRANSPORT:-Smtp}',
    'host' => '${COMANAGE_REGISTRY_EMAIL_HOST:-tls://smtp.gmail.com}',
    'port' => ${COMANAGE_REGISTRY_EMAIL_PORT:-465},
    'username' => '${COMANAGE_REGISTRY_EMAIL_ACCOUNT:-account@gmail.com}',
    'password' => '${COMANAGE_REGISTRY_EMAIL_ACCOUNT_PASSWORD:-password}'
  );
}
EOF
fi

# Loop until we are able to open a connection to the database.
DATABASE_TEST_SCRIPT="$COMANAGE_REGISTRY_DIR/app/Console/Command/DatabaseTestShell.php"

cat > $DATABASE_TEST_SCRIPT <<"EOF"
<?php

App::import('Model', 'ConnectionManager');

class DatabaseTestShell extends AppShell {
  function main() {
    try {
      $db = ConnectionManager::getDataSource('default');
    } catch (Exception $e) {
      $this->error("Unable to connect to datasource");
    }
    $this->out("Connected to datasource");
  }
}
EOF

pushd "$COMANAGE_REGISTRY_DIR/app" > "$OUTPUT" 2>&1

until ./Console/cake databaseTest > "$OUTPUT" 2>&1; do
    >&2 echo "Database is unavailable - sleeping"
    sleep 1
done

rm -f "$DATABASE_TEST_SCRIPT"

popd > "$OUTPUT" 2>&1

# We only want to run the setup script once since it creates
# state in the database. Until COmanage Registry has a better
# mechanism for telling us if setup has already been run
# we create an ephemeral CakePHP script to tell us.
SETUP_ALREADY_SCRIPT="$COMANAGE_REGISTRY_DIR/app/Console/Command/SetupAlreadyShell.php"

cat > $SETUP_ALREADY_SCRIPT <<"EOF"
<?php

class SetupAlreadyShell extends AppShell {
  var $uses = array('Co');

  function main() {
    $args = array();
    $args['conditions']['Co.name'] = 'COmanage';
    $args['contain'] = false;

    try {
      $co = $this->Co->find('first', $args);
    } catch (CakeException $e) {
      $this->out('Not setup already');
    }

    if(empty($co)) {
      $this->out('Not setup already');
    } else {
      $this->error('Setup already');
    }
  }
}
EOF

pushd "$COMANAGE_REGISTRY_DIR/app" > "$OUTPUT" 2>&1
./Console/cake setupAlready > "$OUTPUT" 2>&1
setup_already=$?

rm -f "$SETUP_ALREADY_SCRIPT"

if [ $setup_already -eq 0 ]; then
    rm -f "$COMANAGE_REGISTRY_DIR/local/Config/security.salt" > "$OUTPUT" 2>&1
    rm -f "$COMANAGE_REGISTRY_DIR/local/Config/security.seed" > "$OUTPUT" 2>&1
    ./Console/cake database > "$OUTPUT" 2>&1 && \
    ./Console/cake setup --admin-given-name "${COMANAGE_REGISTRY_ADMIN_GIVEN_NAME}" \
                         --admin-family-name "${COMANAGE_REGISTRY_ADMIN_FAMILY_NAME}" \
                         --admin-username "${COMANAGE_REGISTRY_ADMIN_USERNAME}" \
                         --enable-pooling "${COMANAGE_REGISTRY_ENABLE_POOLING}" > "$OUTPUT" 2>&1
    AUTO_GENERATED_SECURITY=1
fi

popd > "$OUTPUT" 2>&1

# If COmanage Registry CakePHP security salt and seed have been
# injected and the files do not otherwise exist create them.
if [[ -n "$COMANAGE_REGISTRY_SECURITY_SALT" && ( -n "$AUTO_GENERATED_SECURITY" || ! -e "$COMANAGE_REGISTRY_DIR/local/Config/security.salt" ) ]]; then
    echo "$COMANAGE_REGISTRY_SECURITY_SALT" > "$COMANAGE_REGISTRY_DIR/local/Config/security.salt"
fi

if [[ -n "$COMANAGE_REGISTRY_SECURITY_SEED" && ( -n "$AUTO_GENERATED_SECURITY" || ! -e "$COMANAGE_REGISTRY_DIR/local/Config/security.seed" ) ]]; then
    echo "$COMANAGE_REGISTRY_SECURITY_SEED" > "$COMANAGE_REGISTRY_DIR/local/Config/security.seed"
fi

# We always run upgradeVersion since it will not make any changes
# if the current and target versions are the same or if
# an upgrade from the current to the target version is not allowed.
pushd "$COMANAGE_REGISTRY_DIR/app" > "$OUTPUT" 2>&1

./Console/cake upgradeVersion "${COMANAGE_REGISTRY_UPGRADE_VERSION_OPTS}" > "$OUTPUT" 2>&1

popd > "$OUTPUT" 2>&1

# Running CakePHP console commands generates cache files so 
# set the ownership of those files appropriately.
chown -R www-data:www-data "$COMANAGE_REGISTRY_DIR/app/tmp"

# If defined use configured location of Apache HTTP Server 
# HTTPS certificate, key, and CA chain files.
if [ -n "$HTTPS_CERT_FILE" ]; then
    rm -f /etc/apache2/cert.pem
    cp "$HTTPS_CERT_FILE" /etc/apache2/cert.pem
    chown www-data /etc/apache2/cert.pem
    chmod 0644 /etc/apache2/cert.pem
fi

if [ -n "$HTTPS_PRIVKEY_FILE" ]; then
    rm -f /etc/apache2/privkey.pem
    cp "$HTTPS_PRIVKEY_FILE" /etc/apache2/privkey.pem
    chown www-data /etc/apache2/privkey.pem
    chmod 0600 /etc/apache2/privkey.pem
fi

if [ -n "$HTTPS_CHAIN_FILE" ]; then
    rm -f /etc/apache2/chain.pem
    cp "$HTTPS_CHAIN_FILE" /etc/apache2/chain.pem
    chown www-data /etc/apache2/chain.pem
    chmod 0644 /etc/apache2/chain.pem
fi

# first arg is `-f` or `--some-option`
if [ "${1#-}" != "$1" ]; then
    set -- apache2-foreground "$@"
fi

exec "$@"
